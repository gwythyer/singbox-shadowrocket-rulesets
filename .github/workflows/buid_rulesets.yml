name: Build rule-sets (srs + list)

on:
  push:
    paths:
      - "rulesets/source/direct/*.txt"
      - "rulesets/source/proxy/*.txt"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download sing-box
        run: |
          set -euo pipefail
          VERSION=1.12.17
          wget -q https://github.com/SagerNet/sing-box/releases/download/v$VERSION/sing-box-$VERSION-linux-amd64.tar.gz
          tar -xzf sing-box-$VERSION-linux-amd64.tar.gz
          mv sing-box-$VERSION-linux-amd64/sing-box ./sing-box
          chmod +x ./sing-box
          ./sing-box version

      # 1) Precheck источников + сборка агрегатов (direct-domains/proxy-domains)
      - name: Precheck sources & build aggregated domain lists (fail on empty)
        run: |
          set -euo pipefail
          shopt -s nullglob

          mkdir -p .tmp

          for dir in direct proxy; do
            files=(rulesets/source/${dir}/*.txt)

            if [ ${#files[@]} -eq 0 ]; then
              echo "ERROR: No source files found in rulesets/source/${dir}/*.txt"
              exit 1
            fi

            # Проверяем, что каждый файл содержит хотя бы 1 домен (не пустой и не только комменты)
            for f in "${files[@]}"; do
              if ! grep -qE '^[^#[:space:]]' "$f"; then
                echo "ERROR: Empty ruleset source file (or comments/whitespace only): $f"
                exit 1
              fi
            done

            # Собираем агрегированный список доменов (уникальные, отсортированные)
            agg=".tmp/${dir}-domains.txt"
            : > "$agg"
            for f in "${files[@]}"; do
              grep -E '^[^#[:space:]]' "$f" >> "$agg"
            done
            sort -u "$agg" -o "$agg"

            # Доп. защита: агрегат не должен быть пустым
            if [ ! -s "$agg" ]; then
              echo "ERROR: Aggregated list is empty (unexpected): $agg"
              exit 1
            fi

            echo "Aggregated ${dir}: $(wc -l < "$agg") domains -> $agg"
          done

      # 2) Shadowrocket .list (по каждому файлу + агрегаты)
      - name: Generate Shadowrocket .list (fail on empty)
        run: |
          set -euo pipefail
          shopt -s nullglob
          mkdir -p rulesets/shadowrocket/direct rulesets/shadowrocket/proxy

          for dir in direct proxy; do
            # per-file
            for f in rulesets/source/${dir}/*.txt; do
              base=$(basename "$f" .txt)
              name="${dir}-${base}"
              out="rulesets/shadowrocket/${dir}/${name}.list"
              echo "# ${name}" > "$out"
              grep -E '^[^#[:space:]]' "$f" | sed 's/^/DOMAIN-SUFFIX,/' >> "$out"
            done

            # aggregated
            agg=".tmp/${dir}-domains.txt"
            out="rulesets/shadowrocket/${dir}/${dir}-domains.list"
            echo "# ${dir}-domains" > "$out"
            sed 's/^/DOMAIN-SUFFIX,/' "$agg" >> "$out"
          done

      # 3) sing-box JSON (по каждому файлу + агрегаты)
      - name: Generate sing-box JSON (fail on empty)
        run: |
          set -euo pipefail
          shopt -s nullglob
          mkdir -p rulesets/singbox/direct rulesets/singbox/proxy

          make_json () {
            local src="$1"
            local dst="$2"
            {
              echo '{ "version": 1, "rules": [ { "domain_suffix": ['
              # src уже отфильтрован на этапе подготовки/grep, но на всякий:
              grep -E '^[^#[:space:]]' "$src" | sed 's/.*/"&",/' | sed '$ s/,$//'
              echo '] } ] }'
            } > "$dst"
          }

          for dir in direct proxy; do
            # per-file
            for f in rulesets/source/${dir}/*.txt; do
              base=$(basename "$f" .txt)
              name="${dir}-${base}"
              json="rulesets/singbox/${dir}/${name}.json"
              make_json "$f" "$json"
            done

            # aggregated
            agg=".tmp/${dir}-domains.txt"
            json="rulesets/singbox/${dir}/${dir}-domains.json"
            make_json "$agg" "$json"
          done

      - name: Validate sing-box JSON
        run: |
          set -euo pipefail
          shopt -s nullglob
          for f in rulesets/singbox/direct/*.json rulesets/singbox/proxy/*.json; do
            jq empty "$f"
          done

      # 4) Compile SRS (включая direct-domains/proxy-domains)
      - name: Compile SRS
        run: |
          set -euo pipefail
          shopt -s nullglob
          mkdir -p build/direct build/proxy

          for dir in direct proxy; do
            for f in rulesets/singbox/${dir}/*.json; do
              echo "Compiling $f"
              ./sing-box rule-set compile "$f"

              srs="${f%.json}.srs"
              if [ ! -s "$srs" ]; then
                echo "ERROR: $srs is empty or missing"
                exit 1
              fi

              mv "$srs" "build/${dir}/"
            done
          done

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: auto-${{ github.run_number }}
          name: Auto build ${{ github.run_number }}
          body_path: RELEASE.md
          files: |
            build/direct/direct-*.srs
            build/proxy/proxy-*.srs
            rulesets/shadowrocket/direct/direct-*.list
            rulesets/shadowrocket/proxy/proxy-*.list
            singbox/*.json
            shadowrocket/*.conf
